# This workflow is used to create a new release of the libraries. It first does a validation build, to ensure that the code will build,
# then uses the commit history (and Conventional Commits) to generate a changelog, update the version number in the source files, and
# commit the changes to source. This final commit is then used to create the release versions of the libraries, and a draft GitHub release
# is generated using the changelog, with the final compiled files attached.

name: Create Release
run-name: Create Release

on:
  workflow_dispatch:

env:
  BUILD_CONFIGURATION: Release

jobs:

  # Do a build first to verify the code is valid.
  Validate:
    uses: ./.github/workflows/build-libraries.yml

  # Now we know everything is valid, generate the changelog, and update the version number.
  Prep:
    runs-on: ubuntu-latest
    needs: Validate
    outputs:
      commit: ${{ steps.commit-version-number.outputs.commit }}
      releaseMessage: ${{ steps.read-release-message.outputs.content }}
      version: ${{ steps.get-version.outputs.version }}

    steps:

    # Configure Git to use GitHub Actions bot as committer.
    - name: Configure Git Actions Bot
      uses: drengskapur/gitbot-config@00aecab0a790b146951f9e0c48f564eaf26a9df6 # v1.1.2

    # Checkout the repository.
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Read the release message for the body of our tag and release.
    - name: Read Release Message
      id: read-release-message
      uses: juliangruber/read-file-action@v1
      with:
        path: res/release-message.md

    # Generate version number and changelog from Conventional Commits.
    - name: Generate Changelog
      uses: orhun/git-cliff-action@v4
      id: generate-changelog
      with:
        config: build/cliff-changelog.toml
        args: -v --bump
      env:
        GIT_CLIFF_WITH_TAG_MESSAGE: ${{ steps.read-release-message.outputs.content }}
        GITHUB_REPO: ${{ github.repository }}
        OUTPUT: CHANGELOG.md

    # Get the version number. We parse the output from `git-cliff` to remove the leading "v" from the version string.
    - name: Get Version Number
      id: get-version
      shell: pwsh
      run: |
        # Get the raw version number from the git-cliff output.
        Write-Host "Raw Version: ${{ steps.generate-changelog.outputs.version }}"
        $rawVersion = "${{ steps.generate-changelog.outputs.version }}"

        # If the version is null, throw an error.
        if ($rawVersion -like "*null") {
          throw "Version is '$rawVersion'!"
        }

        # Remove the leading "v" from the version string.
        $version = $rawVersion -replace 'v', ''

        # Set the version number as an output variable for later steps.
        "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        Write-Host "'version' set to: $version"

    # Commit the changelog.
    - name: Commit Changelog
      run: |
        git add .
        git commit -m "chore(release): update changelog"
        git push

    # Set the version number in the source project files.
    - name: Set Version Number
      uses: vers-one/dotnet-project-version-updater@v1.7
      with:
        file: |
          "**/*.csproj", "**/*.nuspec", "**/AssemblyInfo.cs"
        version: ${{ steps.get-version.outputs.version }}

    # Commit the changes ready for our production build.
    - name: Commit Version Number
      id: commit-version-number
      run: |
        git add .
        git commit -m "chore(release): update version to ${{ steps.get-version.outputs.version }}"
        git push
        echo "commit=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

    # Delete build artifacts from the Validate step, ready for final artifacts from the Build step.
    - name: Cleanup Build Artifacts
      uses: geekyeggo/delete-artifact@v4
      with:
        name: nupkg-files

  # Now do our build for real.
  Build:
    needs: Prep
    uses: ./.github/workflows/build-libraries.yml
    with:
      commit: ${{ needs.Prep.outputs.commit }}

  # Finally, create the GitHub release using our changelog, version, tag, and build artifacts.
  Release:
    runs-on: ubuntu-latest
    needs: [Build, Prep]
    permissions:
      contents: write

    steps:

    # Checkout the repository.
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ needs.Prep.outputs.commit }}

    # Generate release notes for the latest version from Conventional Commits.
    - name: Generate Release Notes
      uses: orhun/git-cliff-action@v4
      id: generate-release-notes
      with:
        config: build/cliff-releasenotes.toml
        args: -v --strip header --unreleased
      env:
        GIT_CLIFF_WITH_TAG_MESSAGE: ${{ needs.Prep.outputs.releaseMessage }}
        GITHUB_REPO: ${{ github.repository }}
        OUTPUT: RELEASENOTES.md

    # Download build artifacts.
    - name: Download Build Artifacts
      uses: actions/download-artifact@v4

    # Generate the GitHub release.
    - name: Generate GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        body: ${{ steps.generate-release-notes.outputs.content }}
        draft: true
        fail_on_unmatched_files: true
        files: |
          ./**/*.nupkg
          ./**/CHANGELOG.md
        generate_release_notes: false
        make_latest: true
        name: v${{ needs.Prep.outputs.version }}
        preserve_order: true
        tag_name: v${{ needs.Prep.outputs.version }}
        target_commitish: ${{ needs.Prep.outputs.commit }}